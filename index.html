<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Indigo-like Web Camera</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Fullscreen safe area for iOS Safari */
    body {
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    video {
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
    }

    /* Remove smooth transitions for choppy UI */
    * {
      transition: none !important;
      animation: none !important;
    }

    /* Disable smooth scrolling */
    html {
      scroll-behavior: auto;
    }

    /* Camera app specific styles */
    .camera-viewport {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: #000;
      overflow: hidden;
    }

    .camera-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
      padding: 2rem 1rem 1rem;
      z-index: 10;
    }

    .capture-button {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: white;
      border: 4px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .control-button {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
    }

    .status-bar {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(rgba(0, 0, 0, 0.6), transparent);
      padding: 1rem;
      z-index: 10;
    }

    .settings-panel {
      position: absolute;
      top: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      border-radius: 0 0 0 1rem;
      padding: 1rem;
      z-index: 20;
      max-width: 300px;
    }

    .gallery-preview {
      position: absolute;
      top: 1rem;
      left: 1rem;
      width: 60px;
      height: 60px;
      border-radius: 0.5rem;
      border: 2px solid white;
      overflow: hidden;
      z-index: 10;
    }
  </style>
</head>

<body class="bg-black text-white overflow-hidden">
  <!-- Camera Viewport -->
  <div class="camera-viewport">
    <!-- Video Preview -->
    <video id="preview" playsinline autoplay muted class="w-full h-full object-cover"></video>
    <canvas id="frameCanvas" class="hidden"></canvas>

    <!-- Status Bar -->
    <div class="status-bar">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-3">
          <span id="statusChip" class="px-3 py-1 rounded-full text-sm bg-black/50 backdrop-blur">Idle</span>
          <span id="resLabel" class="px-2 py-1 rounded text-xs bg-black/50 backdrop-blur">—</span>
        </div>
        <div class="flex items-center gap-2">
          <button id="settingsBtn" class="control-button flex items-center justify-center">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z">
              </path>
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
            </svg>
          </button>
        </div>
      </div>
    </div>

    <!-- Settings Panel (Hidden by default) -->
    <div id="settingsPanel" class="settings-panel hidden">
      <div class="space-y-4">
        <div class="flex items-center justify-between">
          <h3 class="text-lg font-semibold">Settings</h3>
          <button id="closeSettings" class="control-button">✕</button>
        </div>

        <div>
          <label class="block text-sm font-medium mb-2">Camera</label>
          <div class="flex gap-2 mb-3">
            <button id="startBtn" class="px-4 py-2 rounded-lg bg-white text-black font-medium">Start</button>
            <button id="switchBtn"
              class="px-4 py-2 rounded-lg bg-white/20 text-white border border-white/30">Switch</button>
            <button id="stopBtn"
              class="px-4 py-2 rounded-lg bg-white/20 text-white border border-white/30">Stop</button>
          </div>
          <select id="deviceSelect" class="w-full px-3 py-2 rounded-lg bg-white/10 text-white border border-white/20"
            disabled>
            <option>Select device...</option>
          </select>
        </div>

        <div>
          <label class="block text-sm font-medium mb-2">Burst Count: <span id="burstCountLabel"
              class="text-white/70">8</span></label>
          <input id="burstCount" type="range" min="1" max="16" step="1" value="8" class="w-full">
        </div>

        <div>
          <label class="block text-sm font-medium mb-2">JPEG Quality: <span id="qualityLabel"
              class="text-white/70">0.92</span></label>
          <input id="jpegQuality" type="range" min="0.6" max="1" step="0.01" value="0.92" class="w-full">
        </div>

        <label class="flex items-center gap-2">
          <input id="preferMax" type="checkbox" class="rounded">
          <span class="text-sm">Request highest resolution</span>
        </label>
      </div>
    </div>

    <!-- Gallery Preview -->
    <div id="galleryPreview" class="gallery-preview hidden">
      <img id="lastPhoto" src="" alt="Last photo" class="w-full h-full object-cover">
    </div>

    <!-- Camera Controls -->
    <div class="camera-controls">
      <div class="flex items-center justify-center gap-8">
        <!-- Gallery Button -->
        <button id="galleryBtn" class="control-button flex items-center justify-center">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
            </path>
          </svg>
        </button>

        <!-- Main Capture Button -->
        <button id="takeBtn" class="capture-button flex items-center justify-center">
          <div class="w-16 h-16 rounded-full bg-black"></div>
        </button>

        <!-- Burst Button -->
        <button id="burstBtn" class="control-button flex items-center justify-center">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <!-- Gallery Modal (Hidden by default) -->
  <div id="galleryModal" class="fixed inset-0 bg-black z-50 hidden">
    <div class="h-full flex flex-col">
      <div class="flex items-center justify-between p-4 border-b border-white/20">
        <h2 class="text-xl font-semibold">Gallery</h2>
        <button id="closeGallery" class="control-button">✕</button>
      </div>
      <div id="gallery" class="flex-1 p-4 overflow-y-auto grid grid-cols-2 gap-4"></div>
    </div>
  </div>

  <!-- Log Panel -->
  <div id="logPanel"
    class="fixed bottom-4 left-4 right-4 bg-black/80 backdrop-blur rounded-lg p-3 text-xs text-white/80 hidden">
    <div id="log">Log: —</div>
  </div>

  <script>
    const els = (sel, ctx = document) => [...ctx.querySelectorAll(sel)];
    const el = (sel, ctx = document) => ctx.querySelector(sel);

    const state = {
      stream: null,
      track: null,
      facing: 'environment',
      deviceId: null,
      processor: null,
      reader: null,
      usingProcessor: false,
    };

    const $video = el('#preview');
    const $canvas = el('#frameCanvas');
    const $status = el('#statusChip');
    const $res = el('#resLabel');
    const $log = el('#log');
    const $deviceSelect = el('#deviceSelect');

    const $startBtn = el('#startBtn');
    const $switchBtn = el('#switchBtn');
    const $stopBtn = el('#stopBtn');
    const $takeBtn = el('#takeBtn');
    const $burstBtn = el('#burstBtn');
    const $preferMax = el('#preferMax');

    const $burstRange = el('#burstCount');
    const $burstLabel = el('#burstCountLabel');
    const $quality = el('#jpegQuality');
    const $qualityLabel = el('#qualityLabel');

    const $gallery = el('#gallery');
    const $galleryModal = el('#galleryModal');
    const $galleryBtn = el('#galleryBtn');
    const $closeGallery = el('#closeGallery');
    const $settingsBtn = el('#settingsBtn');
    const $closeSettings = el('#closeSettings');
    const $settingsPanel = el('#settingsPanel');
    const $galleryPreview = el('#galleryPreview');
    const $lastPhoto = el('#lastPhoto');
    const $logPanel = el('#logPanel');

    // UI helpers
    function setStatus(text, color = 'white') {
      $status.textContent = text;
      $status.className = 'px-3 py-1 rounded-full text-sm backdrop-blur';
      if (color === 'green') $status.classList.add('bg-green-600/80');
      else if (color === 'red') $status.classList.add('bg-red-600/80');
      else $status.classList.add('bg-black/50');
    }

    function log(msg) {
      $log.textContent = `Log: ${msg}`;
      $logPanel.classList.remove('hidden');
      setTimeout(() => $logPanel.classList.add('hidden'), 3000);
    }

    function showGallery() {
      $galleryModal.classList.remove('hidden');
    }

    function hideGallery() {
      $galleryModal.classList.add('hidden');
    }

    function toggleSettings() {
      $settingsPanel.classList.toggle('hidden');
    }

    function updateGalleryPreview(blob) {
      const url = URL.createObjectURL(blob);
      $lastPhoto.src = url;
      $galleryPreview.classList.remove('hidden');
      setTimeout(() => URL.revokeObjectURL(url), 60000);
    }

    async function listDevices() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const vids = devices.filter(d => d.kind === 'videoinput');
        $deviceSelect.innerHTML = '<option>Select device...</option>';
        vids.forEach(d => {
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          opt.textContent = d.label || `Camera ${$deviceSelect.length}`;
          $deviceSelect.appendChild(opt);
        });
        $deviceSelect.disabled = vids.length === 0;
      } catch (e) {
        // ignore
      }
    }

    async function startCamera() {
      try {
        setStatus('Starting...');
        const preferMax = $preferMax.checked;
        const baseConstraints = {
          video: {
            facingMode: state.deviceId ? undefined : { ideal: state.facing },
            deviceId: state.deviceId ? { exact: state.deviceId } : undefined,
            width: preferMax ? { ideal: 4096, max: 4096 } : { ideal: 1920 },
            height: preferMax ? { ideal: 2160, max: 4096 } : { ideal: 1080 },
            frameRate: { ideal: 30, max: 60 },
          },
          audio: false,
        };
        const stream = await navigator.mediaDevices.getUserMedia(baseConstraints);
        cleanupStream();
        state.stream = stream;
        state.track = stream.getVideoTracks()[0];
        $video.srcObject = stream;
        await $video.play().catch(() => { });

        // Try to "upgrade" to max capability if allowed
        try {
          const caps = state.track.getCapabilities ? state.track.getCapabilities() : null;
          if (caps && caps.width && caps.height) {
            const target = {
              width: caps.width.max ?? undefined,
              height: caps.height.max ?? undefined,
            };
            await state.track.applyConstraints({ width: target.width, height: target.height });
          }
        } catch (e) { /* best-effort */ }

        // show labels once metadata is ready
        await new Promise(r => {
          if ($video.readyState >= 1) return r();
          $video.onloadedmetadata = () => r();
        });

        // Update UI
        const s = state.track.getSettings ? state.track.getSettings() : {};
        $res.textContent = s.width && s.height ? `${s.width}×${s.height}` : '—';
        setStatus('Ready', 'green');
        log('Camera started');

        // device list (labels need permission first)
        await listDevices();
      } catch (err) {
        console.error(err);
        setStatus('Failed', 'red');
        log(err.message || String(err));
      }
    }

    function cleanupStream() {
      if (state.reader) { try { state.reader.releaseLock(); } catch { } state.reader = null; }
      if (state.processor) { state.processor = null; }
      if (state.stream) {
        state.stream.getTracks().forEach(t => t.stop());
        state.stream = null; state.track = null;
      }
    }

    function stopCamera() {
      cleanupStream();
      $video.srcObject = null;
      setStatus('Stopped');
      $res.textContent = '—';
      log('Stopped');
    }

    async function switchFacing() {
      if ($deviceSelect && !$deviceSelect.disabled && $deviceSelect.value) {
        state.deviceId = null;
      }
      state.facing = state.facing === 'environment' ? 'user' : 'environment';
      await startCamera();
    }

    // Capture helpers
    function videoToCanvas(width, height) {
      const vw = $video.videoWidth;
      const vh = $video.videoHeight;
      const cw = width || vw;
      const ch = height || vh;
      $canvas.width = cw; $canvas.height = ch;
      const ctx = $canvas.getContext('2d');
      ctx.drawImage($video, 0, 0, cw, ch);
      return $canvas;
    }

    function canvasToBlob(canvas, type = 'image/jpeg', quality = 0.92) {
      return new Promise(res => canvas.toBlob(res, type, quality));
    }

    function addToGallery(blob, label = 'photo') {
      const url = URL.createObjectURL(blob);
      const card = document.createElement('div');
      card.className = 'rounded-lg overflow-hidden border border-white/20 bg-white/10';
      card.innerHTML = `
        <img src="${url}" alt="captured" class="w-full aspect-video object-cover" />
        <div class="p-2 text-xs flex items-center justify-between">
          <span class="text-white/80">${label}</span>
          <a href="${url}" download="${label}.jpg" class="text-blue-400 underline">Download</a>
        </div>
      `;
      $gallery.prepend(card);
      setTimeout(() => URL.revokeObjectURL(url), 60_000);
    }

    async function takePhotoMax() {
      if (!state.track) return;
      setStatus('Capturing...');
      try {
        let blob = null;
        // Prefer ImageCapture if available
        if ('ImageCapture' in window) {
          try {
            const ic = new ImageCapture(state.track);
            let opts = {};
            if (ic.getPhotoCapabilities) {
              const caps = await ic.getPhotoCapabilities().catch(() => null);
              if (caps && caps.imageWidth && caps.imageHeight) {
                opts.imageWidth = caps.imageWidth.max;
                opts.imageHeight = caps.imageHeight.max;
              }
            }
            blob = await ic.takePhoto(opts).catch(() => null);
          } catch (e) { /* fallback below */ }
        }
        if (!blob) {
          // Fallback: capture from video element
          const c = videoToCanvas();
          blob = await canvasToBlob(c, 'image/jpeg', parseFloat($quality.value));
        }
        addToGallery(blob, `photo_${new Date().toISOString().replace(/[:.]/g, '-')}`);
        updateGalleryPreview(blob);
        setStatus('Captured!', 'green');
        log('Photo saved');
      } catch (e) {
        console.error(e);
        setStatus('Failed', 'red');
        log(e.message || String(e));
      }
    }

    async function burstStack() {
      if (!state.track) return;
      const n = parseInt($burstRange.value, 10) || 8;
      const quality = parseFloat($quality.value);
      setStatus(`Burst (${n})...`);
      $burstBtn.disabled = true; $takeBtn.disabled = true;
      try {
        const useProcessor = 'MediaStreamTrackProcessor' in window;
        const frames = [];
        let w = $video.videoWidth, h = $video.videoHeight;

        if (useProcessor) {
          const processor = new MediaStreamTrackProcessor({ track: state.track });
          const reader = processor.readable.getReader();
          for (let i = 0; i < n; i++) {
            const { value, done } = await reader.read();
            if (done || !value) break;
            const bmp = await createImageBitmap(value);
            frames.push(bmp);
            if (i === 0) { w = value.displayWidth; h = value.displayHeight; }
            value.close();
          }
          reader.releaseLock();
        } else {
          // Fallback: sample n frames from the <video>
          for (let i = 0; i < n; i++) {
            await new Promise(r => requestAnimationFrame(r));
            const c = videoToCanvas();
            const bmp = await createImageBitmap(c);
            frames.push(bmp);
          }
        }

        // Average stack (no alignment). Simple noise reduction / pseudo-HDR look.
        const out = document.createElement('canvas');
        out.width = w; out.height = h;
        const ctx = out.getContext('2d');
        ctx.clearRect(0, 0, w, h);
        const alpha = 1 / frames.length;
        frames.forEach((bmp, i) => {
          ctx.globalAlpha = alpha;
          ctx.drawImage(bmp, 0, 0, w, h);
        });
        ctx.globalAlpha = 1;

        const blob = await canvasToBlob(out, 'image/jpeg', quality);
        addToGallery(blob, `burst_${n}_${new Date().toISOString().replace(/[:.]/g, '-')}`);
        updateGalleryPreview(blob);
        frames.forEach(b => b.close && b.close());
        setStatus('Stacked!', 'green');
        log('Burst stack complete');
      } catch (e) {
        console.error(e);
        setStatus('Failed', 'red');
        log(e.message || String(e));
      } finally {
        $burstBtn.disabled = false; $takeBtn.disabled = false;
      }
    }

    // Events
    $startBtn.addEventListener('click', startCamera);
    $switchBtn.addEventListener('click', switchFacing);
    $stopBtn.addEventListener('click', stopCamera);
    $takeBtn.addEventListener('click', takePhotoMax);
    $burstBtn.addEventListener('click', burstStack);

    $burstRange.addEventListener('input', () => $burstLabel.textContent = $burstRange.value);
    $quality.addEventListener('input', () => $qualityLabel.textContent = $quality.value);

    $deviceSelect.addEventListener('change', async (e) => {
      state.deviceId = e.target.value || null;
      await startCamera();
    });

    $galleryBtn.addEventListener('click', showGallery);
    $closeGallery.addEventListener('click', hideGallery);
    $settingsBtn.addEventListener('click', toggleSettings);
    $closeSettings.addEventListener('click', toggleSettings);

    // Initial labels
    $burstLabel.textContent = $burstRange.value;
    $qualityLabel.textContent = $quality.value;

    // iOS Safari UX: Don't auto-start, wait for user interaction
  </script>

</body>

</html>