<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Indigo-like Web Camera</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Fullscreen safe area for iOS Safari */
    body {
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    video {
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
    }

    .btn {
      padding: 1rem 1.5rem;
      border-radius: 1rem;
      box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
      transition: all 0.2s;
    }

    .btn:active {
      transform: scale(0.95);
    }

    .btn-primary {
      background-color: black;
      color: white;
    }

    .btn-ghost {
      background-color: rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    .chip {
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.75rem;
      background-color: black;
      color: white;
    }
  </style>
</head>

<body class="min-h-screen bg-neutral-50 text-neutral-900">
  <!-- Header -->
  <header class="max-w-5xl mx-auto px-4 pt-4 pb-2 flex flex-col gap-2">
    <div class="flex items-center justify-between">
      <h1 class="text-xl font-semibold tracking-tight">Indigo-like Web Camera</h1>
      <div class="flex items-center gap-2">
        <span id="statusChip" class="chip">Idle</span>
      </div>
    </div>
    <p class="text-sm text-neutral-600">An experimental app to test burst stacking (simple NR/HDR-like) and maximum-size
      capture (only if supported) using the iPhone rear camera. UI built only with Tailwind CDN.</p>
  </header>

  <!-- Main -->
  <main class="max-w-5xl mx-auto px-4 pb-24">
    <!-- Preview Card -->
    <section class="rounded-3xl overflow-hidden shadow bg-white border border-neutral-200">
      <div class="relative bg-black">
        <video id="preview" playsinline autoplay muted class="w-full aspect-video object-contain bg-black"></video>
        <canvas id="frameCanvas" class="hidden"></canvas>
        <div class="absolute left-3 top-3 flex gap-2 text-white/90 text-xs">
          <span id="resLabel" class="bg-white/20 px-2 py-1 rounded">—</span>
          <span id="camLabel" class="bg-white/20 px-2 py-1 rounded">—</span>
        </div>
      </div>

      <!-- Controls -->
      <div class="p-4 grid md:grid-cols-3 gap-4">
        <div class="space-y-3">
          <div>
            <label class="block text-sm font-medium">Camera</label>
            <div class="mt-2 flex gap-2">
              <button id="startBtn" class="btn btn-primary">Start</button>
              <button id="switchBtn" class="btn btn-ghost" title="Switch front/rear">Switch</button>
              <button id="stopBtn" class="btn btn-ghost">Stop</button>
            </div>
          </div>
          <div>
            <label class="block text-sm font-medium">Device Selection <span class="text-xs text-neutral-500">(shown
                after permission)</span></label>
            <select id="deviceSelect" class="mt-2 w-full rounded-xl border border-neutral-300 px-3 py-2 bg-white"
              disabled></select>
          </div>
          <label class="inline-flex items-center gap-2 text-sm">
            <input id="preferMax" type="checkbox" class="rounded border-neutral-300">
            Request highest resolution (if possible)
          </label>
        </div>

        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium">Burst Count <span id="burstCountLabel"
                class="ml-2 text-xs text-neutral-500">8</span></label>
            <input id="burstCount" type="range" min="1" max="16" step="1" value="8" class="w-full">
            <p class="text-xs text-neutral-500 mt-1">* If MediaStreamTrackProcessor is not supported, fallback to
              preview capture (simple)</p>
          </div>
          <div>
            <label class="block text-sm font-medium">JPEG Quality <span id="qualityLabel"
                class="ml-2 text-xs text-neutral-500">0.92</span></label>
            <input id="jpegQuality" type="range" min="0.6" max="1" step="0.01" value="0.92" class="w-full">
          </div>
        </div>

        <div class="space-y-3">
          <div class="grid grid-cols-2 gap-2">
            <button id="takeBtn" class="btn btn-primary">Still (max if supported)</button>
            <button id="burstBtn" class="btn btn-ghost">Burst Stack</button>
          </div>
          <div class="text-xs text-neutral-600">
            <p>Still: If Image Capture API is available, it captures at the <em>maximum supported</em> size. Otherwise
              captures at preview resolution.</p>
            <p class="mt-1">Burst Stack: Averages multiple frames (simple NR/HDR-like). Ghosting may appear in scenes
              with movement.</p>
          </div>
        </div>
      </div>
    </section>

    <!-- Gallery -->
    <section class="mt-6">
      <h2 class="text-lg font-semibold mb-3">Captured Results</h2>
      <div id="gallery" class="grid sm:grid-cols-2 lg:grid-cols-3 gap-4"></div>
    </section>
  </main>

  <!-- Footer / Logs -->
  <footer class="fixed bottom-0 left-0 right-0 bg-white/90 backdrop-blur border-t border-neutral-200">
    <div class="max-w-5xl mx-auto px-4 py-2 text-xs text-neutral-600 flex items-center justify-between gap-4">
      <div id="log" class="truncate">Log: —</div>
      <div class="flex items-center gap-2">
        <a id="supportLink" href="#" class="underline">Support Status</a>
      </div>
    </div>
  </footer>

  <script>
    const els = (sel, ctx = document) => [...ctx.querySelectorAll(sel)];
    const el = (sel, ctx = document) => ctx.querySelector(sel);

    const state = {
      stream: null,
      track: null,
      facing: 'environment',
      deviceId: null,
      processor: null,
      reader: null,
      usingProcessor: false,
    };

    const $video = el('#preview');
    const $canvas = el('#frameCanvas');
    const $status = el('#statusChip');
    const $res = el('#resLabel');
    const $cam = el('#camLabel');
    const $log = el('#log');
    const $deviceSelect = el('#deviceSelect');

    const $startBtn = el('#startBtn');
    const $switchBtn = el('#switchBtn');
    const $stopBtn = el('#stopBtn');
    const $takeBtn = el('#takeBtn');
    const $burstBtn = el('#burstBtn');
    const $preferMax = el('#preferMax');

    const $burstRange = el('#burstCount');
    const $burstLabel = el('#burstCountLabel');
    const $quality = el('#jpegQuality');
    const $qualityLabel = el('#qualityLabel');

    const $gallery = el('#gallery');

    // UI helpers
    function setStatus(text, color = 'black') {
      $status.textContent = text;
      $status.className = 'chip';
      if (color === 'green') $status.classList.add('bg-green-600');
      else if (color === 'red') $status.classList.add('bg-red-600');
      else $status.classList.add('bg-black');
    }
    function log(msg) { $log.textContent = `Log: ${msg}`; }

    async function listDevices() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const vids = devices.filter(d => d.kind === 'videoinput');
        $deviceSelect.innerHTML = '';
        vids.forEach(d => {
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          opt.textContent = d.label || `Camera ${$deviceSelect.length + 1}`;
          $deviceSelect.appendChild(opt);
        });
        $deviceSelect.disabled = vids.length === 0;
      } catch (e) {
        // ignore
      }
    }

    async function startCamera() {
      try {
        setStatus('Starting...');
        const preferMax = $preferMax.checked;
        const baseConstraints = {
          video: {
            facingMode: state.deviceId ? undefined : { ideal: state.facing },
            deviceId: state.deviceId ? { exact: state.deviceId } : undefined,
            width: preferMax ? { ideal: 4096, max: 4096 } : { ideal: 1920 },
            height: preferMax ? { ideal: 2160, max: 4096 } : { ideal: 1080 },
            frameRate: { ideal: 30, max: 60 },
          },
          audio: false,
        };
        const stream = await navigator.mediaDevices.getUserMedia(baseConstraints);
        cleanupStream();
        state.stream = stream;
        state.track = stream.getVideoTracks()[0];
        $video.srcObject = stream;
        await $video.play().catch(() => { });

        // Try to "upgrade" to max capability if allowed
        try {
          const caps = state.track.getCapabilities ? state.track.getCapabilities() : null;
          if (caps && caps.width && caps.height) {
            const target = {
              width: caps.width.max ?? undefined,
              height: caps.height.max ?? undefined,
            };
            await state.track.applyConstraints({ width: target.width, height: target.height });
          }
        } catch (e) { /* best-effort */ }

        // show labels once metadata is ready
        await new Promise(r => {
          if ($video.readyState >= 1) return r();
          $video.onloadedmetadata = () => r();
        });

        // Update UI
        const s = state.track.getSettings ? state.track.getSettings() : {};
        $res.textContent = s.width && s.height ? `${s.width}×${s.height}@${s.frameRate || '?'}fps` : 'Resolution unavailable';
        $cam.textContent = s.facingMode ? (s.facingMode === 'environment' ? 'Rear' : 'Front') : '—';
        setStatus('Previewing', 'green');
        log('Camera started. Device selection available if needed.');

        // device list (labels need permission first)
        await listDevices();
      } catch (err) {
        console.error(err);
        setStatus('Start failed', 'red');
        log(err.message || String(err));
      }
    }

    function cleanupStream() {
      if (state.reader) { try { state.reader.releaseLock(); } catch { } state.reader = null; }
      if (state.processor) { state.processor = null; }
      if (state.stream) {
        state.stream.getTracks().forEach(t => t.stop());
        state.stream = null; state.track = null;
      }
    }

    function stopCamera() {
      cleanupStream();
      $video.srcObject = null;
      setStatus('Stopped');
      $res.textContent = '—';
      $cam.textContent = '—';
      log('Stopped');
    }

    async function switchFacing() {
      if ($deviceSelect && !$deviceSelect.disabled && $deviceSelect.value) {
        // If user selected a specific device, toggle facingMode may not apply.
        state.deviceId = null; // reset device selection when toggling facing
      }
      state.facing = state.facing === 'environment' ? 'user' : 'environment';
      await startCamera();
    }

    // Capture helpers
    function videoToCanvas(width, height) {
      const vw = $video.videoWidth;
      const vh = $video.videoHeight;
      const cw = width || vw;
      const ch = height || vh;
      $canvas.width = cw; $canvas.height = ch;
      const ctx = $canvas.getContext('2d');
      ctx.drawImage($video, 0, 0, cw, ch);
      return $canvas;
    }

    function canvasToBlob(canvas, type = 'image/jpeg', quality = 0.92) {
      return new Promise(res => canvas.toBlob(res, type, quality));
    }

    function addToGallery(blob, label = 'photo') {
      const url = URL.createObjectURL(blob);
      const card = document.createElement('div');
      card.className = 'rounded-2xl overflow-hidden border border-neutral-200 bg-white shadow';
      card.innerHTML = `
        <img src="${url}" alt="captured" class="w-full aspect-video object-contain bg-black" />
        <div class="p-3 text-sm flex items-center justify-between">
          <span class="text-neutral-700">${label}</span>
          <a href="${url}" download="${label}.jpg" class="underline">Download</a>
        </div>
      `;
      $gallery.prepend(card);
      // Revoke later to avoid breaking download link immediately
      setTimeout(() => URL.revokeObjectURL(url), 60_000);
    }

    async function takePhotoMax() {
      if (!state.track) return;
      setStatus('Capturing...');
      try {
        let blob = null;
        // Prefer ImageCapture if available
        if ('ImageCapture' in window) {
          try {
            const ic = new ImageCapture(state.track);
            let opts = {};
            if (ic.getPhotoCapabilities) {
              const caps = await ic.getPhotoCapabilities().catch(() => null);
              if (caps && caps.imageWidth && caps.imageHeight) {
                opts.imageWidth = caps.imageWidth.max;
                opts.imageHeight = caps.imageHeight.max;
              }
            }
            blob = await ic.takePhoto(opts).catch(() => null);
          } catch (e) { /* fallback below */ }
        }
        if (!blob) {
          // Fallback: capture from video element
          const c = videoToCanvas();
          blob = await canvasToBlob(c, 'image/jpeg', parseFloat($quality.value));
        }
        addToGallery(blob, `photo_${new Date().toISOString().replace(/[:.]/g, '-')}`);
        setStatus('Capture complete', 'green');
        log('Still image saved');
      } catch (e) {
        console.error(e);
        setStatus('Capture failed', 'red');
        log(e.message || String(e));
      }
    }

    async function burstStack() {
      if (!state.track) return;
      const n = parseInt($burstRange.value, 10) || 8;
      const quality = parseFloat($quality.value);
      setStatus(`Burst (${n}) capturing...`);
      $burstBtn.disabled = true; $takeBtn.disabled = true;
      try {
        const useProcessor = 'MediaStreamTrackProcessor' in window;
        const frames = [];
        let w = $video.videoWidth, h = $video.videoHeight;

        if (useProcessor) {
          const processor = new MediaStreamTrackProcessor({ track: state.track });
          const reader = processor.readable.getReader();
          for (let i = 0; i < n; i++) {
            const { value, done } = await reader.read();
            if (done || !value) break;
            const bmp = await createImageBitmap(value);
            frames.push(bmp);
            if (i === 0) { w = value.displayWidth; h = value.displayHeight; }
            value.close();
          }
          reader.releaseLock();
        } else {
          // Fallback: sample n frames from the <video>
          for (let i = 0; i < n; i++) {
            await new Promise(r => requestAnimationFrame(r));
            const c = videoToCanvas();
            const bmp = await createImageBitmap(c);
            frames.push(bmp);
          }
        }

        // Average stack (no alignment). Simple noise reduction / pseudo-HDR look.
        const out = document.createElement('canvas');
        out.width = w; out.height = h;
        const ctx = out.getContext('2d');
        ctx.clearRect(0, 0, w, h);
        const alpha = 1 / frames.length;
        frames.forEach((bmp, i) => {
          ctx.globalAlpha = alpha;
          ctx.drawImage(bmp, 0, 0, w, h);
        });
        ctx.globalAlpha = 1;

        const blob = await canvasToBlob(out, 'image/jpeg', quality);
        addToGallery(blob, `burst_${n}_${new Date().toISOString().replace(/[:.]/g, '-')}`);
        frames.forEach(b => b.close && b.close());
        setStatus('Stacking complete', 'green');
        log('Average stacking complete (simple). Ghosting may appear in scenes with movement.');
      } catch (e) {
        console.error(e);
        setStatus('Stacking failed', 'red');
        log(e.message || String(e));
      } finally {
        $burstBtn.disabled = false; $takeBtn.disabled = false;
      }
    }

    // Events
    $startBtn.addEventListener('click', startCamera);
    $switchBtn.addEventListener('click', switchFacing);
    $stopBtn.addEventListener('click', stopCamera);
    $takeBtn.addEventListener('click', takePhotoMax);
    $burstBtn.addEventListener('click', burstStack);

    $burstRange.addEventListener('input', () => $burstLabel.textContent = $burstRange.value);
    $quality.addEventListener('input', () => $qualityLabel.textContent = $quality.value);

    $deviceSelect.addEventListener('change', async (e) => {
      state.deviceId = e.target.value || null;
      await startCamera();
    });

    el('#supportLink').addEventListener('click', (e) => {
      e.preventDefault();
      alert([
        `getUserMedia: ${!!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)}`,
        `ImageCapture: ${'ImageCapture' in window}`,
        `MediaStreamTrackProcessor: ${'MediaStreamTrackProcessor' in window}`,
      ].join('\n'));
    });

    // Initial labels
    $burstLabel.textContent = $burstRange.value;
    $qualityLabel.textContent = $quality.value;

    // iOS Safari UX: Don't auto-start, wait for user interaction
  </script>

</body>

</html>